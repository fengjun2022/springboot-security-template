# 服务间调用Token签发和权限控制系统 - 完整文档

## 目录
- [系统概述](#系统概述)
- [功能特性](#功能特性)
- [数据库设计](#数据库设计)
- [系统架构](#系统架构)
- [API接口文档](#api接口文档)
- [权限管理](#权限管理)
- [部署指南](#部署指南)
- [使用示例](#使用示例)
- [监控和维护](#监控和维护)
- [故障排除](#故障排除)

## 系统概述

本系统实现了一个完整的服务间调用权限管理方案，为微服务架构提供安全、高效的服务间通信机制。

### 核心功能
- **服务应用注册管理**：动态注册和管理服务应用，自动生成AppID和授权码
- **永久Token签发**：基于JWT的无过期时间Token，确保服务间长期稳定通信
- **高性能权限验证**：内存缓存+Filter机制，毫秒级权限验证
- **细粒度权限控制**：支持精确匹配、通配符匹配等多种权限配置策略
- **Admin权限管控**：关键操作仅限管理员访问

### 技术架构
- **Spring Boot 2.7.16** - 基础框架
- **Spring Security** - 安全框架
- **JWT (java-jwt 4.2.1)** - Token技术
- **MyBatis** - 数据访问层
- **MySQL** - 数据存储
- **雪花ID算法** - 分布式ID生成
- **ConcurrentHashMap** - 高性能内存缓存

## 功能特性

### 1. 服务应用注册
- 支持动态注册服务应用
- 自动生成AppID（使用雪花ID）
- 自动生成32位安全授权码
- 配置允许访问的接口列表（JSON格式存储）
- 支持应用启用/禁用状态管理
- **仅管理员可操作**：注册、更新、删除应用

### 2. Token签发管理
- 基于JWT的永久Token（无过期时间）
- Token与AppID强绑定验证
- 支持Token重新生成和批量失效
- 记录Token使用情况和统计信息
- **仅管理员可操作**：签发、失效Token

### 3. 双重权限验证机制
- **用户调用权限**：基于Spring Security的用户认证和角色权限
- **服务间调用权限**：基于ServicePermissionFilter的appId+token验证
- **智能识别**：通过`X-Service-Call`请求头自动区分调用类型
- **高性能缓存**：ConcurrentHashMap实现毫秒级权限查询
- **白名单机制**：排除静态资源和管理接口，避免误拦截

### 4. 权限配置策略
支持多种灵活的权限匹配模式：
- **精确匹配**：`/api/user/profile`
- **前缀通配符**：`/api/user/*` 
- **后缀通配符**：`*/export`
- **全局匹配**：`*`
- **复合配置**：混合使用多种模式

### 5. 缓存管理系统
- **启动自动加载**：应用启动时自动初始化权限缓存
- **实时刷新**：支持单应用和全局缓存刷新
- **性能监控**：缓存命中率、查询统计
- **缓存清理**：支持指定应用和全局缓存清理
- **仅管理员可操作**：缓存管理操作

## 数据库设计

### service_app（服务应用表）
```sql
CREATE TABLE `service_app` (
    `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID，自增',
    `app_name` VARCHAR(100) NOT NULL COMMENT '应用名称',
    `app_id` VARCHAR(50) NOT NULL COMMENT '应用唯一标识，使用雪花ID生成',
    `auth_code` VARCHAR(100) NOT NULL COMMENT '授权码，自动生成的密钥',
    `allowed_apis` TEXT COMMENT '允许访问的接口列表，JSON格式存储',
    `status` TINYINT(1) NOT NULL DEFAULT 1 COMMENT '应用状态：1-启用，0-禁用',
    `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `update_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    `create_by` VARCHAR(50) COMMENT '创建者',
    `update_by` VARCHAR(50) COMMENT '更新者',
    `remark` VARCHAR(500) COMMENT '备注',
    PRIMARY KEY (`id`),
    UNIQUE KEY `uk_app_name` (`app_name`),
    UNIQUE KEY `uk_app_id` (`app_id`),
    KEY `idx_status` (`status`),
    KEY `idx_app_id_status` (`app_id`, `status`)
);
```

### service_token（服务Token表）
```sql
CREATE TABLE `service_token` (
    `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID，自增',
    `app_id` VARCHAR(50) NOT NULL COMMENT '应用ID，关联service_app表',
    `token` TEXT NOT NULL COMMENT '签发的token',
    `token_type` VARCHAR(20) NOT NULL DEFAULT 'permanent' COMMENT 'token类型',
    `status` TINYINT(1) NOT NULL DEFAULT 1 COMMENT 'token状态：1-有效，0-失效',
    `issue_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '签发时间',
    `last_used_time` DATETIME COMMENT '最后使用时间',
    `issue_by` VARCHAR(50) COMMENT '签发者',
    `remark` VARCHAR(500) COMMENT '备注',
    PRIMARY KEY (`id`),
    KEY `idx_app_id_status` (`app_id`, `status`),
    CONSTRAINT `fk_service_token_app_id` FOREIGN KEY (`app_id`) REFERENCES `service_app` (`app_id`)
);
```

### 示例数据
```sql
INSERT INTO `service_app` VALUES 
(1,'用户服务','1750123456789012345','abc123def456ghi789','["/api/user/*","/api/auth/validate"]',1,'2025-01-27 10:00:00','2025-01-27 10:00:00','admin',NULL,'用户管理相关服务'),
(2,'订单服务','1750123456789012346','pqr678stu901vwx234','["/api/order/*","/api/payment/*"]',1,'2025-01-27 10:01:00','2025-01-27 10:01:00','admin',NULL,'订单和支付相关服务'),
(3,'通知服务','1750123456789012347','efg345hij678klm901','["/api/notification/*","/api/sms/*"]',1,'2025-01-27 10:02:00','2025-01-27 10:02:00','admin',NULL,'消息通知相关服务');
```

## 系统架构

### 架构图
```
┌─────────────┐                    ┌─────────────────────────────────────┐
│   前端用户   │────👤 用户调用────────►│                                     │
│  Web/Mobile │   (用户Token)        │         权限管理中心                 │
└─────────────┘                    │                                     │
                                   │  ┌───────────────────────────────┐   │
┌─────────────┐                    │  │    ServicePermissionFilter   │   │
│   服务A     │──┐                 │  │                               │   │
│[Token:ABC]  │  │                 │  │  检查 X-Service-Call 请求头    │   │
└─────────────┘  │  🔗 服务间调用    │  │          ↓                   │   │
                 │ (appId+Token)    │  │    有标识      │    无标识      │   │
┌─────────────┐  │                 │  │      ↓        │      ↓        │   │
│   服务B     │──┼─────────────────►│  │  服务权限验证   │  跳过验证      │   │
│[Token:DEF]  │  │                 │  │   - 验证appid  │   走Spring    │   │
└─────────────┘  │                 │  │   - 验证token  │   Security    │   │
                 │                 │  │   - 检查权限   │               │   │
┌─────────────┐  │                 │  └───────────────────────────────┘   │
│   服务C     │──┘                 │                                     │
│[Token:GHI]  │                    │  ┌───────────────────────────────┐   │
└─────────────┘                    │  │      权限缓存                  │   │
                                   │  │   ConcurrentHashMap          │   │
                                   │  │    - appId -> 接口列表        │   │
                                   │  │    - 高性能查询              │   │
                                   │  │    - 实时统计                │   │
                                   │  └───────────────────────────────┘   │
                                   │                                     │
                                   │  ┌───────────────────────────────┐   │
                                   │  │       管理API (需ADMIN权限)    │   │
                                   │  │    - 应用注册                 │   │
                                   │  │    - Token签发                │   │
                                   │  │    - 权限配置                 │   │
                                   │  └───────────────────────────────┘   │
                                   └─────────────┬───────────────────────┘
                                                 │
                                   ┌─────────────▼───────────────┐
                                   │           MySQL             │
                                   │     - service_app          │
                                   │     - service_token        │
                                   └─────────────────────────────┘
```

### 核心组件

#### 1. ServicePermissionFilter
```java
@Component
@Order(1) // 高优先级执行
public class ServicePermissionFilter extends OncePerRequestFilter {
    // 验证逻辑：
    // 1. 检查X-Service-Call标识
    // 2. 验证appid和token
    // 3. 查询权限缓存
    // 4. 匹配接口权限
}
```

#### 2. PermissionCacheService
```java
@Service
public class PermissionCacheServiceImpl implements PermissionCacheService {
    // 高性能缓存：
    // - ConcurrentHashMap存储权限
    // - 启动时自动加载
    // - 支持实时刷新
    // - 缓存统计监控
}
```

#### 3. 双重权限验证流程
```
请求到达 → ServicePermissionFilter 
    ↓
检查 X-Service-Call 请求头
    ↓                    ↓
有标识(服务调用)          无标识(用户调用)
    ↓                    ↓
验证 appId + Token     跳过，走Spring Security
    ↓                    ↓
查询权限缓存            用户认证 + 角色权限
    ↓                    ↓
匹配接口权限            业务逻辑处理
    ↓
放行/拒绝
```

## API接口文档

### 调用方式说明

#### 👤 用户调用（普通业务接口）
用户通过前端应用调用业务接口时，使用Spring Security标准认证：
```http
GET /api/user/profile
Authorization: Bearer {user_jwt_token}
```
**特点**：
- 不需要 `X-Service-Call` 请求头
- 不需要 `appid` 参数
- 使用用户JWT Token
- 经过Spring Security用户认证和角色权限验证

#### 🔗 服务间调用（微服务内部通信）
微服务之间进行内部调用时，使用服务权限验证：
```http
GET /api/notification/send
X-Service-Call: true
appid: 1750123456789012345
Authorization: Bearer {service_permanent_token}
```
**特点**：
- 必须包含 `X-Service-Call: true` 请求头
- 必须包含 `appid` 参数（服务应用ID）
- 使用永久服务Token
- 经过ServicePermissionFilter权限验证

### 权限说明
🔒 表示需要admin权限的接口
👤 表示用户调用接口
🔗 表示服务间调用接口

### 服务应用管理 (/api/service-app)

#### 1. 🔒 注册服务应用
```http
POST /api/service-app/register
Content-Type: application/json
Authorization: Bearer {admin_token}

{
    "appName": "用户服务",
    "allowedApis": ["/api/user/*", "/api/auth/validate"],
    "createBy": "admin",
    "remark": "用户管理相关服务"
}
```

**响应示例：**
```json
{
    "code": 200,
    "message": "success",
    "data": {
        "id": 1,
        "appName": "用户服务",
        "appId": "1750123456789012345",
        "authCode": "abc123def456ghi789jkl012mno345",
        "allowedApis": "[\"/api/user/*\", \"/api/auth/validate\"]",
        "status": 1,
        "createTime": "2025-01-27T10:00:00"
    }
}
```

#### 2. 查询所有应用
```http
GET /api/service-app/list
```

#### 3. 查询启用应用
```http
GET /api/service-app/enabled
```

#### 4. 根据ID查询
```http
GET /api/service-app/{id}
```

#### 5. 🔒 更新应用
```http
PUT /api/service-app/update
Content-Type: application/json
Authorization: Bearer {admin_token}

{
    "id": 1,
    "appName": "用户服务-更新",
    "allowedApiList": ["/api/user/*", "/api/auth/*"],
    "updateBy": "admin"
}
```

#### 6. 🔒 更新应用状态
```http
PUT /api/service-app/{id}/status?status=0
Authorization: Bearer {admin_token}
```

#### 7. 🔒 删除应用
```http
DELETE /api/service-app/{id}
Authorization: Bearer {admin_token}
```

#### 8. 验证应用
```http
POST /api/service-app/validate
Content-Type: application/x-www-form-urlencoded

appId=1750123456789012345&authCode=abc123def456ghi789
```

#### 9. 检查权限
```http
GET /api/service-app/permission/check?appId=1750123456789012345&apiPath=/api/user/profile
```

### Token管理 (/api/service-token)

#### 1. 🔒 签发Token
```http
POST /api/service-token/issue
Content-Type: application/json
Authorization: Bearer {admin_token}

{
    "appId": "1750123456789012345",
    "authCode": "abc123def456ghi789",
    "issueBy": "admin"
}
```

**响应示例：**
```json
{
    "code": 200,
    "message": "success",
    "data": {
        "id": 1,
        "appId": "1750123456789012345",
        "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...",
        "tokenType": "permanent",
        "status": 1,
        "issueTime": "2025-01-27T10:00:00"
    }
}
```

#### 2. 验证Token
```http
POST /api/service-token/validate?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...
```

#### 3. 根据AppID获取Token
```http
GET /api/service-token/app/{appId}
```

#### 4. 🔒 失效Token
```http
PUT /api/service-token/{tokenId}/invalidate
Authorization: Bearer {admin_token}
```

#### 5. 🔒 重新生成Token
```http
POST /api/service-token/regenerate
Content-Type: application/json
Authorization: Bearer {admin_token}

{
    "appId": "1750123456789012345",
    "authCode": "abc123def456ghi789",
    "issueBy": "admin"
}
```

#### 6. 🔒 批量失效Token
```http
PUT /api/service-token/app/{appId}/invalidate
Authorization: Bearer {admin_token}
```

### 权限缓存管理 (/api/permission-cache)

#### 1. 🔒 初始化缓存
```http
POST /api/permission-cache/init
Authorization: Bearer {admin_token}
```

#### 2. 🔒 刷新应用权限缓存
```http
POST /api/permission-cache/refresh/{appId}
Authorization: Bearer {admin_token}
```

#### 3. 🔒 清除应用权限缓存
```http
DELETE /api/permission-cache/{appId}
Authorization: Bearer {admin_token}
```

#### 4. 获取应用权限列表
```http
GET /api/permission-cache/{appId}/permissions
```

#### 5. 检查权限
```http
GET /api/permission-cache/check?appId=1750123456789012345&apiPath=/api/user/profile
```

#### 6. 🔒 清除所有缓存
```http
DELETE /api/permission-cache/clear
Authorization: Bearer {admin_token}
```

#### 7. 获取缓存统计
```http
GET /api/permission-cache/stats
```

**响应示例：**
```json
{
    "code": 200,
    "message": "success",
    "data": "缓存统计 - 总请求: 1000, 命中: 950, 未命中: 50, 命中率: 95.00%, 缓存应用数: 3"
}
```

## 权限管理

### 管理员权限设计

系统采用**双重权限控制**机制：

#### 1. Spring Security方法级权限
关键管理操作使用`@PreAuthorize("hasRole('ADMIN')")`注解保护：
- 服务应用的注册、更新、删除
- Token的签发、失效、重新生成  
- 权限缓存的管理操作

#### 2. 服务间调用权限
业务接口使用ServicePermissionFilter进行权限验证。

### 权限配置策略详解

#### 精确匹配
适用于需要精确控制的特定接口：
```json
["/api/user/profile", "/api/user/settings", "/api/order/create"]
```

#### 通配符匹配
适用于模块级权限控制：

**前缀匹配：**
```json
["/api/user/*"]  // 匹配 /api/user/list, /api/user/profile 等
```

**后缀匹配：**
```json
["*/export"]     // 匹配 /api/user/export, /api/order/export 等
```

**全局匹配：**
```json
["*"]           // 匹配所有接口（谨慎使用）
```

#### 混合配置示例
实际生产环境推荐的配置策略：
```json
{
    "appName": "用户服务",
    "allowedApis": [
        "/api/user/*",           // 用户模块所有接口
        "/api/auth/validate",    // 特定的认证接口
        "/api/system/health",    // 健康检查接口
        "*/export",              // 所有导出接口
        "/api/common/upload"     // 特定的公共接口
    ]
}
```

### 权限验证流程
```
1. 请求到达 ServicePermissionFilter
2. 检查请求头：X-Service-Call: true
3. 提取并验证：appid 和 Authorization Token
4. 从缓存查询应用权限列表
5. 使用匹配算法验证接口权限
6. 记录访问日志和统计信息
7. 放行请求或返回403错误
```

## 部署指南

### 1. 环境要求
- **JDK 1.8+**
- **MySQL 5.7+**
- **Maven 3.6+**
- **Spring Boot 2.7.16**

### 2. 数据库准备
```bash
# 1. 创建数据库
mysql -u root -p
CREATE DATABASE zxy_hospital DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

# 2. 执行初始化脚本
mysql -u root -p zxy_hospital < service_auth.sql
```

### 3. 配置文件
更新 `application-{env}.yml` 配置：
```yaml
sbt:
  datasource:
    host: your_mysql_host
    port: 3306
    database: zxy_hospital
    username: your_username
    password: your_password
```

### 4. 编译部署
```bash
# 编译项目
mvn clean compile -DskipTests

# 打包项目
mvn clean package -DskipTests

# 启动应用
java -jar server/target/server-1.0.0.jar --spring.profiles.active=prod
```

### 5. 验证部署
```bash
# 检查应用启动状态
curl http://localhost:8080/api/permission-cache/stats

# 查看启动日志
tail -f logs/system.log
```

启动成功后会看到：
```
=== 应用启动完成，开始初始化权限缓存 ===
开始初始化权限缓存...
权限缓存初始化完成，缓存应用数量: 3
=== 权限缓存初始化成功 ===
```

## 使用示例

### 完整工作流程示例

#### 场景：用户服务需要调用通知服务发送邮件

#### 步骤1：管理员登录并注册通知服务
```bash
# 1. 管理员登录获取token
curl -X POST "http://localhost:8080/login" \
     -H "Content-Type: application/json" \
     -d '{"username": "admin", "password": "admin123"}'

# 响应获取admin_token
# {"code":200,"data":{"token":"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..."}}

# 2. 注册通知服务应用
curl -X POST "http://localhost:8080/api/service-app/register" \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer {admin_token}" \
     -d '{
       "appName": "通知服务",
       "allowedApis": ["/api/notification/*", "/api/sms/send", "/api/email/send"],
       "createBy": "admin",
       "remark": "消息通知服务"
     }'
```

#### 步骤2：为通知服务签发Token
```bash
curl -X POST "http://localhost:8080/api/service-token/issue" \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer {admin_token}" \
     -d '{
       "appId": "1750123456789012346",
       "authCode": "xyz789abc456def123ghi789jkl012",
       "issueBy": "admin"
     }'
```

#### 步骤3：测试两种调用方式

##### 👤 用户调用示例（用户通过前端访问接口）
```bash
# 用户登录获取用户token
curl -X POST "http://localhost:8080/login" \
     -H "Content-Type: application/json" \
     -d '{"username": "user", "password": "password"}'

# 用户调用业务接口（不需要appid）
curl -X GET "http://localhost:8080/api/user/profile" \
     -H "Authorization: Bearer {user_token}"

curl -X GET "http://localhost:8080/api/order/list" \
     -H "Authorization: Bearer {user_token}"
```

##### 🔗 服务间调用示例（微服务内部通信）
```bash
# 用户服务调用通知服务发送欢迎邮件
curl -X POST "http://localhost:8080/api/email/send" \
     -H "Content-Type: application/json" \
     -H "X-Service-Call: true" \
     -H "appid: 1750123456789012346" \
     -H "Authorization: Bearer {service_token}" \
     -d '{
       "to": "user@example.com",
       "subject": "欢迎注册",
       "content": "欢迎您注册我们的服务！"
     }'
```

### Java代码示例

#### 在Spring Boot服务中进行服务间调用
```java
@Service
public class UserNotificationService {
    
    private static final String NOTIFICATION_SERVICE_APP_ID = "1750123456789012346";
    private static final String NOTIFICATION_SERVICE_TOKEN = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...";
    
    @Autowired
    private RestTemplate restTemplate;
    
    public void sendWelcomeEmail(String userEmail, String userName) {
        // 设置服务间调用的请求头
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("X-Service-Call", "true");
        headers.set("appid", NOTIFICATION_SERVICE_APP_ID);
        headers.set("Authorization", "Bearer " + NOTIFICATION_SERVICE_TOKEN);
        
        // 构建请求体
        Map<String, Object> emailRequest = new HashMap<>();
        emailRequest.put("to", userEmail);
        emailRequest.put("subject", "欢迎注册");
        emailRequest.put("content", "欢迎您，" + userName + "！");
        
        HttpEntity<Map<String, Object>> requestEntity = new HttpEntity<>(emailRequest, headers);
        
        // 发起服务间调用
        try {
            ResponseEntity<String> response = restTemplate.postForEntity(
                "http://notification-service/api/email/send", 
                requestEntity, 
                String.class
            );
            
            if (response.getStatusCode().is2xxSuccessful()) {
                System.out.println("欢迎邮件发送成功");
            }
        } catch (Exception e) {
            System.err.println("发送欢迎邮件失败: " + e.getMessage());
        }
    }
}
```

#### 配置RestTemplate Bean
```java
@Configuration
public class ServiceConfig {
    
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

#### Token配置管理
```java
@Component
@ConfigurationProperties(prefix = "service.tokens")
public class ServiceTokenConfig {
    
    private Map<String, TokenInfo> services = new HashMap<>();
    
    @Data
    public static class TokenInfo {
        private String appId;
        private String token;
    }
    
    public TokenInfo getServiceToken(String serviceName) {
        return services.get(serviceName);
    }
    
    // getters and setters
}
```

对应的配置文件：
```yaml
service:
  tokens:
    notification:
      appId: "1750123456789012346"
      token: "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..."
    user:
      appId: "1750123456789012345"
      token: "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..."
```

### 权限动态管理示例

#### 1. 查看当前权限配置
```bash
# 查看所有应用
curl "http://localhost:8080/api/service-app/list"

# 查看指定应用权限
curl "http://localhost:8080/api/permission-cache/1750123456789012345/permissions"
```

#### 2. 动态更新权限
```bash
# 更新应用权限
curl -X PUT "http://localhost:8080/api/service-app/update" \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer {admin_token}" \
     -d '{
       "id": 1,
       "appName": "用户服务",
       "allowedApiList": ["/api/user/*", "/api/auth/*", "/api/profile/*", "/api/settings/*"],
       "updateBy": "admin"
     }'

# 刷新权限缓存
curl -X POST "http://localhost:8080/api/permission-cache/refresh/1750123456789012345" \
     -H "Authorization: Bearer {admin_token}"
```

#### 3. 权限验证测试
```bash
# 测试有权限的接口
curl -X GET "http://localhost:8080/api/user/list" \
     -H "X-Service-Call: true" \
     -H "appid: 1750123456789012345" \
     -H "Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..."

# 测试无权限的接口（应该返回403）
curl -X GET "http://localhost:8080/api/order/list" \
     -H "X-Service-Call: true" \
     -H "appid: 1750123456789012345" \
     -H "Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..."
```

## 监控和维护

### 1. 性能监控

#### 缓存性能监控
```bash
# 获取缓存统计信息
curl "http://localhost:8080/api/permission-cache/stats"

# 响应示例
{
    "code": 200,
    "data": "缓存统计 - 总请求: 10000, 命中: 9500, 未命中: 500, 命中率: 95.00%, 缓存应用数: 5"
}
```

#### 关键指标监控
建议监控以下指标：
- **缓存命中率**：>95%为健康状态
- **权限验证响应时间**：<5ms为正常
- **Token验证成功率**：>98%为正常
- **服务调用频率**：监控异常峰值

#### 日志监控
系统会输出关键操作日志：
```
2025-01-27 10:00:00 INFO  - 权限缓存初始化完成，缓存应用数量: 5
2025-01-27 10:01:00 WARN  - Token验证失败，appId: 1750123456789012345
2025-01-27 10:02:00 ERROR - 无权限访问接口: /api/order/list, appId: 1750123456789012345
```

### 2. 缓存管理

#### 定期缓存维护
```bash
# 每日定时刷新缓存
0 2 * * * curl -X POST "http://localhost:8080/api/permission-cache/init" -H "Authorization: Bearer {admin_token}"

# 监控缓存状态
*/5 * * * * curl "http://localhost:8080/api/permission-cache/stats" | logger -t cache-monitor
```

#### 缓存故障处理
```bash
# 缓存异常时重新初始化
curl -X DELETE "http://localhost:8080/api/permission-cache/clear" \
     -H "Authorization: Bearer {admin_token}"
     
curl -X POST "http://localhost:8080/api/permission-cache/init" \
     -H "Authorization: Bearer {admin_token}"
```

### 3. Token管理维护

#### Token使用情况检查
```bash
# 检查长时间未使用的token
SELECT app_id, token_type, issue_time, last_used_time, 
       DATEDIFF(NOW(), last_used_time) as days_unused
FROM service_token 
WHERE status = 1 
  AND last_used_time < DATE_SUB(NOW(), INTERVAL 30 DAY);
```

#### Token安全轮换
```bash
# 定期重新生成token（建议每季度）
curl -X POST "http://localhost:8080/api/service-token/regenerate" \
     -H "Authorization: Bearer {admin_token}" \
     -d "appId={appId}&authCode={authCode}&issueBy=system"
```

### 4. 数据库维护

#### 性能优化SQL
```sql
-- 清理过期的失效token记录（保留6个月）
DELETE FROM service_token 
WHERE status = 0 
  AND issue_time < DATE_SUB(NOW(), INTERVAL 6 MONTH);

-- 分析表性能
ANALYZE TABLE service_app, service_token;

-- 查看慢查询
SELECT * FROM information_schema.processlist WHERE time > 1;
```

#### 数据备份策略
```bash
# 每日备份脚本
#!/bin/bash
backup_date=$(date +%Y%m%d)
mysqldump -u root -p zxy_hospital service_app service_token > backup_${backup_date}.sql
find ./backups -name "backup_*.sql" -mtime +30 -delete
```

## 故障排除

### 常见问题及解决方案

#### 1. 权限验证失败 (403 Forbidden)

**问题现象：**
```json
{
    "code": 403,
    "message": "无权限访问该接口: /api/user/profile"
}
```

**排查步骤：**
```bash
# 1. 检查应用是否存在且启用
curl "http://localhost:8080/api/service-app/list" | grep "appId"

# 2. 检查权限配置
curl "http://localhost:8080/api/permission-cache/{appId}/permissions"

# 3. 验证接口路径匹配
curl "http://localhost:8080/api/permission-cache/check?appId={appId}&apiPath=/api/user/profile"

# 4. 刷新权限缓存
curl -X POST "http://localhost:8080/api/permission-cache/refresh/{appId}" \
     -H "Authorization: Bearer {admin_token}"
```

**解决方案：**
- 确认appId正确且应用状态为启用
- 检查权限配置是否包含目标接口
- 更新权限配置并刷新缓存

#### 2. Token验证失败

**问题现象：**
```json
{
    "code": 401,
    "message": "Token验证失败"
}
```

**排查步骤：**
```bash
# 1. 验证token格式
echo "Token: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9..."

# 2. 检查token状态
curl -X POST "http://localhost:8080/api/service-token/validate?token={token}"

# 3. 验证appId与token匹配
curl "http://localhost:8080/api/service-token/app/{appId}"
```

**解决方案：**
- 确认token格式正确（Bearer前缀）
- 检查token是否已失效
- 重新生成token

#### 3. 缓存未生效

**问题现象：**
缓存命中率低或权限更新后未生效

**排查步骤：**
```bash
# 1. 查看缓存统计
curl "http://localhost:8080/api/permission-cache/stats"

# 2. 检查应用启动日志
grep "权限缓存" logs/system.log

# 3. 查看数据库连接
curl "http://localhost:8080/api/service-app/enabled"
```

**解决方案：**
```bash
# 手动重新初始化缓存
curl -X POST "http://localhost:8080/api/permission-cache/init" \
     -H "Authorization: Bearer {admin_token}"

# 清除并重建缓存
curl -X DELETE "http://localhost:8080/api/permission-cache/clear" \
     -H "Authorization: Bearer {admin_token}"
```

#### 4. 数据库连接问题

**问题现象：**
```
SQLException: No database selected
或
Could not connect to database
```

**解决方案：**
```yaml
# 检查配置文件
sbt:
  datasource:
    host: your_host
    port: 3306
    database: zxy_hospital  # 确保数据库名正确
    username: your_username
    password: your_password
```

```bash
# 测试数据库连接
mysql -h your_host -P 3306 -u your_username -p zxy_hospital
```

#### 5. 服务调用被误拦截

**问题现象：**
正常业务接口被ServicePermissionFilter拦截

**解决方案：**
检查请求头，只有包含`X-Service-Call: true`的请求才会被权限验证：
```bash
# 普通用户请求（不会被拦截）
curl -X GET "http://localhost:8080/api/user/profile" \
     -H "Authorization: Bearer {user_token}"

# 服务间调用（会被权限验证）
curl -X GET "http://localhost:8080/api/user/profile" \
     -H "X-Service-Call: true" \
     -H "appid: {appId}" \
     -H "Authorization: Bearer {service_token}"
```

### 性能问题排查

#### 1. 响应时间过长
```bash
# 检查数据库查询性能
SHOW PROCESSLIST;

# 查看慢查询日志
SHOW VARIABLES LIKE 'slow_query_log';

# 分析缓存命中率
curl "http://localhost:8080/api/permission-cache/stats"
```

#### 2. 内存使用过高
```bash
# 检查缓存大小
curl "http://localhost:8080/api/permission-cache/stats"

# 清理无用缓存
curl -X DELETE "http://localhost:8080/api/permission-cache/clear" \
     -H "Authorization: Bearer {admin_token}"
```

### 日志分析

#### 关键日志位置
- **应用日志**：`logs/system.log`
- **权限验证日志**：搜索`ServicePermissionFilter`
- **缓存操作日志**：搜索`PermissionCache`

#### 日志分析命令
```bash
# 查看权限验证失败的记录
grep "无权限访问" logs/system.log | tail -20

# 统计token验证失败次数
grep "Token验证失败" logs/system.log | wc -l

# 监控实时日志
tail -f logs/system.log | grep -E "(权限|Token|Cache)"
```

---

## 总结

本系统为微服务架构提供了完整的服务间调用权限管理解决方案，具有以下优势：

### 🎯 核心优势
- **高性能**：内存缓存 + 高效算法，毫秒级权限验证
- **高安全**：JWT Token + 授权码双重验证，admin权限管控
- **高可用**：缓存容错机制，服务重启自动恢复
- **易管理**：完善的API接口，支持动态权限配置
- **易扩展**：模块化设计，支持自定义权限策略

### 🚀 生产建议
- **监控告警**：配置缓存命中率、响应时间监控
- **定期维护**：Token轮换、缓存清理、数据备份
- **安全加固**：HTTPS传输、敏感信息加密存储
- **性能优化**：根据业务量调整缓存策略和数据库连接池

### 📞 技术支持
如遇到问题，可通过以下方式获取支持：
- 查看详细的API文档和错误码说明
- 分析系统日志和性能监控数据
- 参考故障排除章节的解决方案

本系统已在生产环境验证，可为企业级微服务架构提供稳定可靠的权限管理服务！
