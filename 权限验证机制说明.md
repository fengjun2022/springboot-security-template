# 权限验证机制说明

## 🎯 核心设计理念

本系统实现了**双重权限验证机制**，智能区分用户调用和服务间调用，提供不同的权限验证策略。

## 🔄 两种调用方式对比

| 特性 | 👤 用户调用 | 🔗 服务间调用 |
|-----|------------|-------------|
| **调用者** | 前端用户（Web/Mobile） | 微服务之间 |
| **认证方式** | Spring Security用户认证 | appId + 服务Token |
| **请求头要求** | `Authorization: Bearer {user_token}` | `X-Service-Call: true`<br/>`appid: {app_id}`<br/>`Authorization: Bearer {service_token}` |
| **权限验证** | 用户角色权限（RBAC） | 接口权限列表匹配 |
| **Token类型** | 用户JWT Token（有过期时间） | 服务永久Token（无过期时间） |
| **验证Filter** | Spring Security标准流程 | ServicePermissionFilter |

## 🚀 验证流程详解

### 1. 请求到达ServicePermissionFilter

```java
@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) {
    String serviceCallFlag = request.getHeader("X-Service-Call");
    
    if (!"true".equals(serviceCallFlag)) {
        // 👤 用户调用：跳过服务权限验证，走Spring Security
        filterChain.doFilter(request, response);
        return;
    }
    
    // 🔗 服务间调用：进行appId + token验证
    // ... 验证逻辑
}
```

### 2. 用户调用流程
```
前端请求 → ServicePermissionFilter (跳过) → Spring Security → 用户认证 → 角色权限检查 → 业务Controller
```

### 3. 服务间调用流程
```
服务请求 → ServicePermissionFilter → 验证X-Service-Call → 验证appId → 验证Token → 查询权限缓存 → 匹配接口权限 → 业务Controller
```

## 📝 实际使用示例

### 用户调用示例

#### 场景：用户查看个人资料
```bash
# 用户登录
curl -X POST "http://localhost:8080/login" \
     -H "Content-Type: application/json" \
     -d '{"username": "admin", "password": "123456"}'

```


```bash
# 用户调用个人资料接口
curl -X GET "http://localhost:8080/api/user/profile" \
     -H "Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImxvZ2luVHlwZSI6IlVTRVJfTE9HSU4iLCJleHAiOjE3NTYyNDIwOTUsImF1dGhvcml0aWVzIjoiUk9MRV9BRE1JTiJ9.hLeYToGDExvSjJmlrKHc2NAaA1D79hwrgVhRS2R1hRk"
```

**权限验证过程：**
1. ServicePermissionFilter检查无`X-Service-Call`头，跳过
2. Spring Security验证用户Token
3. 提取用户信息和角色
4. 执行业务逻辑

### 服务间调用示例

#### 场景：用户服务调用通知服务发送邮件
```bash
# 用户服务向通知服务发送邮件请求
curl -X POST "http://localhost:8080/api/notification/email/send" \
     -H "Content-Type: application/json" \
     -H "X-Service-Call: true" \
     -H "appid: 1750123456789012345" \
     -H "Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJ6eHktaG9zcGl0YWwtYWRtaW4iLCJzdWIiOiIxNzUwMTIzNDU2Nzg5MDEyMzQ1In0.xxx" \
     -d '{
       "to": "user@example.com",
       "subject": "欢迎注册",
       "content": "欢迎您注册我们的服务！"
     }'
```

**权限验证过程：**
1. ServicePermissionFilter检查到`X-Service-Call: true`
2. 提取并验证`appid: 1750123456789012345`
3. 验证服务Token的有效性
4. 从缓存查询该应用的权限列表：`["/api/notification/*", "/api/email/*"]`
5. 匹配请求路径`/api/notification/email/send`与权限`/api/notification/*`
6. 匹配成功，放行请求

## 🔧 配置管理

### 服务应用注册（仅ADMIN可操作）
```bash
# 管理员注册新的服务应用
curl -X POST "http://localhost:8080/api/service-app/register" \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer {admin_token}" \
     -d '{
       "appName": "订单服务",
       "allowedApis": ["/api/order/*", "/api/payment/*", "/api/inventory/check"],
       "createBy": "admin",
       "remark": "订单和支付相关服务"
     }'
```

### Token签发（仅ADMIN可操作）
```bash
# 为服务应用签发永久Token
curl -X POST "http://localhost:8080/api/service-token/issue" \
     -H "Authorization: Bearer {admin_token}" \
     -d "appId=1750123456789012346" \
     -d "authCode=xyz789abc456def123" \
     -d "issueBy=admin"
```

## 🎯 权限匹配规则

### 通配符支持
| 配置 | 匹配示例 | 说明 |
|-----|---------|------|
| `/api/user/*` | `/api/user/profile`<br/>`/api/user/settings` | 前缀匹配 |
| `*/export` | `/api/order/export`<br/>`/api/user/export` | 后缀匹配 |
| `*` | 所有接口 | 全匹配（谨慎使用） |
| `/api/user/profile` | `/api/user/profile` | 精确匹配 |

### 复合权限配置示例
```json
{
    "appName": "用户服务",
    "allowedApis": [
        "/api/user/*",              // 用户模块所有接口
        "/api/auth/validate",       // 特定认证接口
        "/api/common/upload",       // 文件上传接口
        "*/export",                 // 所有导出接口
        "/api/system/health"        // 健康检查接口
    ]
}
```

## ⚡ 性能优化

### 高性能缓存机制
```java
// 启动时自动加载所有权限到内存
private final ConcurrentHashMap<String, List<String>> permissionCache = new ConcurrentHashMap<>();

// 权限验证时直接从内存查询（毫秒级）
public boolean hasPermission(String appId, String apiPath) {
    List<String> allowedApis = permissionCache.get(appId);
    // 快速匹配算法
}
```

### 缓存统计监控
```bash
# 查看缓存性能
curl "http://localhost:8080/api/permission-cache/stats"
# 响应: "缓存统计 - 总请求: 10000, 命中: 9500, 未命中: 500, 命中率: 95.00%, 缓存应用数: 5"
```

## 🔒 安全特性

### 1. Token安全
- **用户Token**：有过期时间，定期刷新
- **服务Token**：永久有效，签名验证，定期轮换

### 2. 权限隔离
- **管理权限**：只有ADMIN角色可以注册应用、签发Token
- **业务权限**：基于角色的用户权限控制
- **服务权限**：基于接口列表的精确权限控制

### 3. 防护机制
- **请求头验证**：必须有正确的标识才进入对应验证流程
- **Token绑定**：服务Token与appId强绑定
- **白名单机制**：静态资源和管理接口自动排除

## 🎉 系统优势

✅ **智能分流**：自动识别调用类型，采用不同验证策略  
✅ **高性能**：内存缓存，毫秒级权限验证  
✅ **高安全**：双重权限控制，多层防护机制  
✅ **易管理**：完善的管理接口，支持动态配置  
✅ **易扩展**：模块化设计，支持自定义权限策略  
✅ **易监控**：详细的统计信息和日志记录

这种设计既保证了系统的安全性，又保持了良好的性能和可维护性！🚀
